<!DOCTYPE html> <html> <head> <title>Binary Search Tree with SIMD – Clément Jean – Eternal learner and challenges lover</title> <meta charset="utf-8" /> <meta content='text/html; charset=utf-8' http-equiv='Content-Type'> <meta http-equiv='X-UA-Compatible' content='IE=edge'> <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'> <meta name="description" content="Recently, I've been looking at cache friendly algorithm for common data structures like trees, tries, ... One such algorithm kept coming up to mind and that's why I decided to implement it in Go. You can find the paper describing the algorithm here. " /> <meta property="og:description" content="Recently, I've been looking at cache friendly algorithm for common data structures like trees, tries, ... One such algorithm kept coming up to mind and that's why I decided to implement it in Go. You can find the paper describing the algorithm here. " /> <meta name="author" content="Clément Jean" /> <meta property="og:title" content="Binary Search Tree with SIMD" /> <meta property="twitter:title" content="Binary Search Tree with SIMD" /> <link href="https://techhub.social/@clementjean" rel="me"> <link rel="stylesheet" type="text/css" href="/style.css" /> <link rel="alternate" type="application/rss+xml" title="Clément Jean - Eternal learner and challenges lover" href="/feed.xml" /> <link rel="icon" type="image/png" href="/images/%E4%B8%80%E4%BB%8B%E5%A5%BD%E5%AD%A6.png"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono"/><link rel="stylesheet" href="/assets/codeblock.css"/><script src="/assets/codeblock.js"></script></head> <body> <div class="wrapper-masthead"> <div class="container"> <header class="masthead clearfix"> <a href="/" aria-label="Home" class="site-avatar"><img src="/images/%E4%B8%80%E4%BB%8B%E5%A5%BD%E5%AD%A6.png" alt="Clement Jean" width="80" height="70"/></a> <div class="site-info"> <h1 class="site-name"><a class="black-red-link" href="/">Clément Jean</a></h1> <p class="site-description">Eternal learner and challenges lover</p> </div> <nav> <a class="black-red-link" href="/">Home</a> <a class="black-red-link" href="/categories">Categories</a> <a class="black-red-link" href="/hire_me">Hire Me</a> <a class="black-red-link" href="/about">About</a> </nav> </header> </div> </div> <div id="main" role="main" class="container"> <article class="post"> <h1>Binary Search Tree with SIMD</h1> <div class="entry"> <p>Recently, I've been looking at cache friendly algorithm for common data structures like trees, tries, ... One such algorithm kept coming up to mind and that's why I decided to implement it in Go. You can find the paper describing the algorithm <a href="https://dl.acm.org/doi/10.1145/1807167.1807206">here</a>.</p> <h2 id="the-intuition">The Intuition</h2> <p>Let's assume that we have a binary tree:</p> <div class="code_switcher_container_parent c3f4b3cd-808d-444b-b582-88ba4ecef6df"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code>      ┌────── 41 ──────┐
      │                │
   ┌──23──┐       ┌───61───┐
   │      │       │        │
┌─11─┐  ┌─31─┐  ┌─47─┐  ┌─73─┐
│    │  │    │  │    │  │    │
2   19  29  37  43  53  67  79
</code></pre></div> <p>A normal way of representing a binary tree into an array is by representing it like so:</p> <div class="code_switcher_container_parent eda60361-9e4f-4609-9ae3-9e407920d2cd"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code>┌────┬────┬────┬────┬────┬────┬────┬───┬────┬────┬────┬────┬────┬────┬────┐
│ 41 │ 23 │ 61 │ 11 │ 31 │ 47 │ 73 │ 2 │ 19 │ 29 │ 37 │ 47 │ 53 │ 67 │ 79 │
└────┴────┴────┴────┴────┴────┴────┴───┴────┴────┴────┴────┴────┴────┴────┘
</code></pre></div> <p>or, in other words, we have the level nodes layed out consecutively.</p> <p>This approach however, is not that cache friendly. While the locality of the data for a level is good, in a binary search, we actually care more about the parent-children locality. This is because, by keeping the children next to the parent, we wouldn't need to jump far ahead in the array.</p> <p>The paper mentionned at the beginning, propose to have a binary tree layed out like the following:</p> <div class="code_switcher_container_parent f7517a96-44d7-4182-b783-10c917399c47"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code>┌────┬────┬────┬────┬───┬────┬────┬────┬────┬────┬────┬────┬────┬────┬────┐
│ 41 │ 23 │ 61 │ 11 │ 2 │ 19 │ 31 │ 29 │ 37 │ 47 │ 43 │ 53 │ 73 │ 67 │ 79 │
└────┴────┴────┴────┴───┴────┴────┴────┴────┴────┴────┴────┴────┴────┴────┘
</code></pre></div> <p>And if you take time to understand how this maps back to the binary tree, you will notice that we are storing parent-children triangles. With this, we can now apply SIMD operations on both the parent and the children in order to either dtermine if the data we are looking for is in the triangle, or if we should continue our search.</p> <p>The next important thing to understand is how we do the search of elements.</p> <p>Let's take an example to make things clearer. Let's say that we are looking for the number 62. We will start by loading 41, 23, 61 into a vector.</p> <div class="code_switcher_container_parent 01a7be38-f617-40e7-bc98-c6762114d81f"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code>┌────┬────┬────┐
│ 41 │ 23 │ 61 │
└────┴────┴────┘
</code></pre></div> <p>Then, we will compare (smaller than) each number with the element we are looking for:</p> <div class="code_switcher_container_parent 1dc23680-4eae-48b1-ad31-b75a87638f6a"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code>┌────┬────┬────┐
│ 41 │ 23 │ 61 │
└────┴────┴────┘
        &lt;
┌────┬────┬────┐
│ 62 │ 62 │ 62 │
└────┴────┴────┘
        =
┌────┬────┬────┐
│  1 │  1 │  1 │
└────┴────┴────┘
</code></pre></div> <p>and with the mask we get, we can map to an index in the following subtrees. Here is the full mapping:</p> <div class="code_switcher_container_parent 29b86ddb-208d-43f5-869b-485397bec7a5"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code> 0 0 0 -&gt; 0
 0 1 0 -&gt; 1
 1 1 0 -&gt; 2
 1 1 1 -&gt; 3
</code></pre></div> <p>It's actually a popcount.</p> <p>So, with our <code>[1, 1, 1]</code>, we should access the 4th child (mapping is 0 indexed).</p> <p>If you look at the binary tree, this means that we need to go to the number 73 and we now have the vector:</p> <div class="code_switcher_container_parent 9792714a-02fc-4ce6-8d40-fe4a2b0887e3"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code>┌────┬────┬────┐
│ 73 │ 67 │ 79 │
└────┴────┴────┘
</code></pre></div> <p>Now, we can obviously repeat the process.</p> <p>On top of the lookup for index, we also need to be able to check the equality of the search vector and the curr loaded vector. This is as simple as:</p> <div class="code_switcher_container_parent 8e0b52a3-c78c-4e30-87cb-40d8f22f45d8"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code>┌────┬────┬────┐
│ 41 │ 23 │ 61 │
└────┴────┴────┘
       ==
┌────┬────┬────┐
│ 62 │ 62 │ 62 │
└────┴────┴────┘
        =
┌────┬────┬────┐
│  0 │  0 │  0 │
└────┴────┴────┘
</code></pre></div> <p>If we found a 1, it would mean that the element is in the tree. Otherwise, we keep running as long as we are within the boundaries of the array.</p> <p>Hopefully, this all makes sense. Let us move to the code.</p> <h2 id="the-code">The Code</h2> <p>As <a href="https://github.com/golang/go/issues/67520">my proposal for adding SIMD intrinsics</a> is still not evaluated/accepted, we will need to write Go assembly (ARM64) to make use of SIMD instructions. I'll try to be as clear as possible on what each instruction is doing but you should know at least basics of assembly.</p> <p>Let's start by defining the function definition in our <code>main.go</code>:</p> <div class="code_switcher_container_parent d66fbb15-cce8-4235-91bb-bad87d3011a7"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">func</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">arr</span> <span class="p">[]</span><span class="kt">uint32</span><span class="p">,</span> <span class="n">n</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">bool</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="c">//...</span>
<span class="p">}</span>
</code></pre></div></div> </div> <p>You can see that we are working with uint32s. This is because on ARM64 Neon, we only have 128 bits, and as we need to load at least 3 elements per triangle, uint32 is our best choice.</p> <p>Next, we will jump to our <code>main.s</code> file and start defining our function:</p> <div class="code_switcher_container_parent 44bb8cfa-8bf6-4841-bec4-57fb3d067bf6"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code class="language-asm">>#include &quot;textflag.h&quot;

//func binarySearch(arr []int, n int) bool
TEXT ·binarySearch(SB),NOSPLIT,$0-33
	//...
</code></pre></div> <p>The most important thing here is the <code>$0-33</code> part. We are saying that we do not have local variables (0) and that our arguments/return value take 33 bytes (24 for the slice, 8 for the int, and 1 for the bool).</p> <p>Next, as part of my function, I generally like to define some names for the register. It helps me remember what each register is supposed to contain. This looks like this:</p> <div class="code_switcher_container_parent e7793726-93c2-4daa-b6f8-9700bd68dfdc"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code class="language-asm">>TEXT ·binarySearch(SB),NOSPLIT,$0-33
#define data R0
#define dataLen R1
#define toFind R2
#define curr R3
#define tmp R4
#define child_idx R5
#define nb_subtree R6
#define level R7
#define searchKey V0
#define mask V1
#define idx V2
#define one V3
#define equalMask V4
</code></pre></div> <p>With that, we can initialize the registers and check the base cases:</p> <div class="code_switcher_container_parent c5babe9b-3d78-4e2d-8f8d-861bae6b492e"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code class="language-asm">>TEXT ·binarySearch(SB),NOSPLIT,$0-33
//...

    // initialize registers
	MOVD arr+0(FP), data
	MOVD arr_len+8(FP), dataLen
	MOVD n+24(FP), toFind
	MOVD $0, curr
	MOVD $1, level
	MOVD $0, nb_subtree
	VDUP level, one.S4

    // if array len is 0 return false
	CMP $0, dataLen
	BEQ not_found

    // if array len &gt; 1 start the work
	// otherwise check if the first element is equal
	//  to the one we are looking for
	CMP $1, dataLen
	BGT load
	MOVD (data), tmp
	CMP tmp, toFind
	BEQ found
	B not_found

	//...

not_found:
	MOVD $0, R19 // false
	MOVD R19, ret+32(FP)
	RET

found:
	MOVD $1, R19 // true
	MOVD R19, ret+32(FP)
	RET
</code></pre></div> <p>Now, we can start the real work. We will have a simple loop which we load 4 elements at the <code>curr</code> position in <code>data</code>:</p> <div class="code_switcher_container_parent 49dc8da4-0ba7-4c60-a9c9-f26a8644b4ec"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code class="language-asm">>TEXT ·binarySearch(SB),NOSPLIT,$0-33
//...

load:
	VDUP toFind, searchKey.S4

check:
	CMP dataLen, curr
	BGE not_found

loop:
	MOVD $4, R19
	MUL R19, curr
	ADD curr, data, R19
	VLD1 (R19), [mask.S4]

	//TODO update curr

	B check
</code></pre></div> <p>Notice that we are multiplying <code>curr</code> by 4. This is because we are working with uint32s (4 bytes) so our index (<code>curr</code>) need to be moved by <code>curr * 4</code> bytes.</p> <p>Then, inside the loop, we will check for equality between the four loaded elements and the search vector:</p> <div class="code_switcher_container_parent 22f84cc6-7d82-43a9-bb23-5f6578be9a04"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code class="language-asm">>TEXT ·binarySearch(SB),NOSPLIT,$0-33
//...

loop:
	//...

	VCMEQ mask.S4, searchKey.S4, equalMask.S4
	WORD $0x6eb0a893 //umaxv.4s s19, v4
	FMOVS F19, R19
	CMP $4294967295, R19
	BEQ found

	//...
</code></pre></div> <p>You can notice that if the maximum value inside <code>equalMask</code> is <code>math.MaxUint32</code> (4294967295), it means that we found the element and thus we can return.</p> <p>After that, we fall into the binary search algorithm. We will first start by looking for the index:</p> <div class="code_switcher_container_parent 9786383a-ae24-460c-8be1-f58a2e40a002"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code class="language-asm">>TEXT ·binarySearch(SB),NOSPLIT,$0-33
//...

loop:
	//...

	WORD $0x6ea13401 //cmhi.4s v1, v0, v1
	MOVD $0, R19
	VMOV R19, mask.S[3]
	VAND mask.B16, one.B16, idx.B16
	WORD $0x6eb0384f //uaddlv.4s d15, v2
	FMOVD F15, child_idx

	//...
</code></pre></div> <p>The <code>cmhi</code> checks whether the data we are looking for is bigger that the data we loaded. Then, we bitwise AND the loaded vector with ones and finally, we do a basic popcount to determine the <code>child_idx</code>.</p> <p>Finally, we need to update the <code>curr</code>, <code>level</code>, and the <code>nb_subtree</code>. As mentionned, the former is telling us from where to read the data in the array. The two last ones actually help us calculate the <code>curr</code> by running the following formula: <code>curr = nb_subtree * 3 + (3 * (child_idx + 1))</code>.</p> <div class="code_switcher_container_parent c0c58d8a-df6b-41a8-a257-251a8ad3c325"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div><pre><code class="language-asm">>TEXT ·binarySearch(SB),NOSPLIT,$0-33
//...

loop:
	//...

	//curr = nb_subtree * 3 + (3 * (child_idx + 1))
	MOVD child_idx, tmp
	ADD $1, tmp
	MOVD $3, R19
	MUL R19, tmp
	MOVD tmp, curr
	MUL R19, nb_subtree, R19
	ADD R19, curr

	//nb_subtree = level &lt;&lt; 2
	LSL $2, level, nb_subtree

	//level++
	ADD $1, level

	//...
</code></pre></div> <p>And that actually is all for the binary search algorithm.</p> <h2 id="a-demo">A Demo</h2> <p>We can now go back to our <code>main.go</code> and try it.</p> <div class="code_switcher_container_parent 270e2ca7-71a4-4baf-8d2a-35f8c9ceff92"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="s">"fmt"</span>

<span class="k">func</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">arr</span> <span class="p">[]</span><span class="kt">uint32</span><span class="p">,</span> <span class="n">n</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">bool</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">arr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">uint32</span><span class="p">{</span><span class="m">41</span><span class="p">,</span> <span class="m">23</span><span class="p">,</span> <span class="m">61</span><span class="p">,</span> <span class="m">11</span><span class="p">,</span> <span class="m">2</span><span class="p">,</span> <span class="m">19</span><span class="p">,</span> <span class="m">31</span><span class="p">,</span> <span class="m">29</span><span class="p">,</span> <span class="m">37</span><span class="p">,</span> <span class="m">47</span><span class="p">,</span> <span class="m">43</span><span class="p">,</span> <span class="m">53</span><span class="p">,</span> <span class="m">73</span><span class="p">,</span> <span class="m">67</span><span class="p">,</span> <span class="m">79</span><span class="p">}</span>

  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="m">19</span><span class="p">))</span>
  <span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">binarySearch</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="m">100</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div></div> </div> <p>and if we run, we should have:</p> <div class="code_switcher_container_parent 01037a14-5c76-4f35-805f-118a4b8f08e8"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>go run <span class="nb">.</span>
<span class="nb">true
false</span>
</code></pre></div></div> </div> <h2 id="conclusion">Conclusion</h2> <p>In this article we saw a cache friendly version of the binary search using SIMD. While, we focused on the algorithm itself, I worked on this as part of a data structure. It is an AVL Tree that can be frozen at any point, and once frozen, it will let you do the binary search described in this article.</p> <p>If you would like to have more details on the data structure implemented, or if you have feedback on this article, let me know in the comments section!</p> </div> <div class="date"> Written on July 9, 2024 </div> <div class="comments"> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'clement-jean-github-io-1'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> </div> </article> </div> <div class="wrapper-footer"> <div class="container"> <footer class="footer"> <a href="mailto:clement.jean@epitech.eu" aria-label="Email"><i class="svg-icon email"></i></a> <a href="https://github.com/Clement-Jean" aria-label="Github"><i class="svg-icon github"></i></a> <a href="https://www.linkedin.com/in/clement-jean" aria-label="LinkedIn"><i class="svg-icon linkedin"></i></a> <a href="/feed.xml" aria-label="RSS"><i class="svg-icon rss"></i></a> <a href="https://www.twitter.com/ClmentJean1" aria-label="Twitter"><i class="svg-icon twitter"></i></a> <a href="http://stackoverflow.com/users/11269045/clément-jean" aria-label="StackOverflow"><i class="svg-icon stackoverflow"></i></a> <a href="https://techhub.social/@clementjean" aria-label="Mastodon"><i class="svg-icon mastodon"></i></a> </footer> </div> </div> <!-- Google Analytics --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-111260962-1', 'auto'); ga('send', 'pageview', { 'page': '/simd_binary_search_tree/', 'title': 'Binary Search Tree with SIMD' }); </script> <!-- End Google Analytics --> </body> </html>

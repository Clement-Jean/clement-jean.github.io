<!DOCTYPE html> <html> <head> <title>gRPC Go Server Embeddings – Clément Jean – Eternal learner and challenges lover</title> <meta charset="utf-8" /> <meta content='text/html; charset=utf-8' http-equiv='Content-Type'> <meta http-equiv='X-UA-Compatible' content='IE=edge'> <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'> <meta name="description" content=" One of the common thing that my students are asking about recently is the difference between 2 Type Embeddings when your are defining a Server type for Service Registration. While this is an important topic, the gRPC doc seems to only mention that the Unimplemented version is for Forward Compatibility, and my course, up until now, uses the name of the generated Service Server directly. As such, I thought I would give an explanation on why I now recommend to use Unimplemented and some examples of the 3 Type Embeddings that you can use. " /> <meta property="og:description" content=" One of the common thing that my students are asking about recently is the difference between 2 Type Embeddings when your are defining a Server type for Service Registration. While this is an important topic, the gRPC doc seems to only mention that the Unimplemented version is for Forward Compatibility, and my course, up until now, uses the name of the generated Service Server directly. As such, I thought I would give an explanation on why I now recommend to use Unimplemented and some examples of the 3 Type Embeddings that you can use. " /> <meta name="author" content="Clément Jean" /> <meta property="og:title" content="gRPC Go Server Embeddings" /> <meta property="twitter:title" content="gRPC Go Server Embeddings" /> <link href="https://techhub.social/@clementjean" rel="me"> <link rel="stylesheet" type="text/css" href="/style.css" /> <link rel="alternate" type="application/rss+xml" title="Clément Jean - Eternal learner and challenges lover" href="/feed.xml" /> <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/Clement-Jean/clement-jean.github.io/master/images/%E4%B8%80%E4%BB%8B%E5%A5%BD%E5%AD%A6.png"> </head> <body> <div class="wrapper-masthead"> <div class="container"> <header class="masthead clearfix"> <a href="/" class="site-avatar"><img src="https://raw.githubusercontent.com/Clement-Jean/clement-jean.github.io/master/images/%E4%B8%80%E4%BB%8B%E5%A5%BD%E5%AD%A6.png" /></a> <div class="site-info"> <h1 class="site-name"><a class="black-red-link" href="/">Clément Jean</a></h1> <p class="site-description">Eternal learner and challenges lover</p> </div> <nav> <a class="black-red-link" href="/">Home</a> <a class="black-red-link" href="/categories">Categories</a> <a class="black-red-link" href="/hire_me">Hire Me</a> <a class="black-red-link" href="/about">About</a> </nav> </header> </div> </div> <div id="main" role="main" class="container"> <article class="post"> <h1>gRPC Go Server Embeddings</h1> <div class="entry"> <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Mono"/><link rel="stylesheet" href="/assets/codeblock.css"/><script src="/assets/codeblock.js"></script> <p>One of the common thing that my students are asking about recently is the difference between 2 Type Embeddings when your are defining a Server type for Service Registration. While this is an important topic, the gRPC doc seems to only mention that the <code>Unimplemented</code> version is for Forward Compatibility, and my course, up until now, uses the name of the generated Service Server directly. As such, I thought I would give an explanation on why I now recommend to use <code>Unimplemented</code> and some examples of the 3 Type Embeddings that you can use.</p> <h2 id="type-embedding">Type Embedding</h2> <p>One thing that might not be clear for everyone is what is a Type Embedding and why we need it in gRPC. The first thing to understand is that Go is a language that uses composition instead of inheritance. And if you don't know about Composition or you just want a refresher, you friend Wikipedia is here: <a href="https://en.wikipedia.org/wiki/Composition_over_inheritance">Composition over Inheritance</a>.</p> <p>On top of composition, Go allows anonymous fields in a struct. While I think anonymous field is a misnomer because the field can be referenced by the type name, these provide a shorter way (no need for Identifier) of writing composition. Let's take an example:</p> <div class="code_switcher_container_parent 2a798b09-5b4b-4942-a551-7271fe61124e"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">A</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">s</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">B</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">s</span> <span class="kt">string</span>
	<span class="n">A</span> <span class="c">// no identifier here, just a type</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">b</span> <span class="n">B</span>

	<span class="n">b</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="s">"Test"</span>
	<span class="n">b</span><span class="o">.</span><span class="n">A</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="s">"Another Test"</span> <span class="c">// notice that we can access A even if it's 'anonymous'</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> </div> <p>In this example, we augmented <code>B</code> with the fields defined in <code>A</code>. The ouput of this program should be something like: <code>{Test {Another Test}}</code> where the outter object is <code>B</code> and the inner object is <code>A</code>.</p> <p>So in the end this is just a convenient way of writing composition.</p> <h2 id="grpc-go">gRPC Go</h2> <p>Now, that we are clear on what is a Type Embedding, we can talk about its role in gRPC. As we know the protoc compiler will generate some code for our services, and we also know that services are contracts between a server and client. So basically, because we have a contract we need to make sure that this is implemented on both side of the wire.</p> <p>So if we define a dummy service:</p> <div class="code_switcher_container_parent e5ecd4ba-9a08-4e0a-a351-3ae92cb2f949"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">service</span> <span class="n">DummyService</span> <span class="p">{</span> <span class="p">}</span>
</code></pre></div></div> </div> <p>And we generate our code:</p> <div class="code_switcher_container_parent 26aa9c79-f046-418e-a247-79d1746b027d"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>protoc <span class="nt">--grpc-go_out</span><span class="o">=</span><span class="nb">.</span> dummy.proto 
</code></pre></div></div> </div> <p>We have the following generated server code (simplified):</p> <div class="code_switcher_container_parent e65f0abc-4b97-45f0-b2c0-2ee8dc39e402"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// DummyServiceServer is the server API for DummyService service.</span>
<span class="c">// All implementations must embed UnimplementedDummyServiceServer</span>
<span class="c">// for foward compatibility</span>
<span class="k">type</span> <span class="n">DummyServiceServer</span> <span class="k">interface</span> <span class="p">{</span>
	<span class="n">mustEmbedUnimplementedDummyServiceServer</span><span class="p">()</span>
<span class="p">}</span>

<span class="c">// UnimplementedDummyServiceServer must be embedded to have forward compatible implementations.</span>
<span class="k">type</span> <span class="n">UnimplementedDummyServiceServer</span> <span class="k">struct</span> <span class="p">{</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">UnimplementedDummyServiceServer</span><span class="p">)</span> <span class="n">mustEmbedUnimplementedDummyServiceServer</span><span class="p">()</span> <span class="p">{}</span>

<span class="c">// UnsafeDummyServiceServer may be embedded to opt out of forward compatibility for this service.</span>
<span class="c">// Use of this interface is not recommended, as added methods to DummyServiceServer will</span>
<span class="c">// result in compilation errors.</span>
<span class="k">type</span> <span class="n">UnsafeDummyServiceServer</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">mustEmbedUnimplementedDummyServiceServer</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> </div> <p>First, we can notice a <code>mustEmbedUnimplementedDummyServiceServer</code> function. While I'm not entirely sure what this is doing since I can still compile without the <code>Unimplemented</code> embedding, I read on <a href="https://github.com/grpc/grpc-go/issues/3794">Issue 3794</a> that <code>RegisterDummyService</code> will require (probrably in the future) the Server to embed the <code>UnimplementedDummyServiceServer</code>.</p> <p>Then, as mentionned in the <code>DummyServiceServer</code> documentation, this is the server API. This means that when we add rpc endpoints to our service in the .proto file, methods will be generated into that interface.</p> <p>The second type will always be empty. However, once we add rpc endpoints, a method will be added to this type and this method will simply return a gRPC error.</p> <p>And finally, the last type will stay as is and no methods will be added to it.</p> <h2 id="servicenameserver">${ServiceName}Server</h2> <p>This is the type embedding I used in my course. However, this is a mistake to use this directly. Let's see why.</p> <p>Let's first add a rpc endpoint to our DummyService, this will help when we actually want to see the difference between the type embeddings by calling an endpoint.</p> <div class="code_switcher_container_parent 670afafc-52f7-4dcc-83f8-f41d3b377eb7"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-proto highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="s">"google/protobuf/empty.proto"</span><span class="p">;</span>

<span class="kd">service</span> <span class="n">DummyService</span> <span class="p">{</span>
	<span class="k">rpc</span> <span class="n">GetDummy</span><span class="p">(</span><span class="n">google.protobuf.Empty</span><span class="p">)</span> <span class="k">returns</span> <span class="p">(</span><span class="n">google.protobuf.Empty</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> </div> <p>Then our Server type will look like this:</p> <div class="code_switcher_container_parent f0ecd9c0-6ec1-45ba-a7fc-27cc3e0dcb8f"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">struct</span> <span class="n">Server</span> <span class="p">{</span>
	<span class="n">DummyServiceServer</span>
<span class="p">}</span>
</code></pre></div></div> </div> <p>So, right now, we didn't implement <code>GetDummy</code> rpc endpoint. What happens if we try to call it ? The server runs perfectly, no compilation error, but once you call the rpc endpoint it will panic. This is where this type embedding is not Forward Compatible because an service which doesn't have a complete implementation of our service might cause a panic when comunicating with one that has the implementation.</p> <h2 id="unsafeservicenameserver">Unsafe${ServiceName}Server</h2> <p>Let's skip the <code>Unimplemented</code> for now and let's take a look at the <code>Unsafe</code> type emdeding. Before explaining it though, I want to mention two things:</p> <ul> <li><code>Unsafe</code> sounds really bad. However in some specific cases, this embedding might actually be useful.</li> <li>The type documentation says that this type is not recommended, but once again, be aware that it might be useful.</li> </ul> <p>With that said, let's get started. Let's replace our type embedding:</p> <div class="code_switcher_container_parent 8e304ce3-3162-4721-a464-fd8c3b788e2e"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="k">struct</span> <span class="n">Server</span> <span class="p">{</span>
	<span class="n">UnsafeDummyServiceServer</span>
<span class="p">}</span>
</code></pre></div></div> </div> <p>In this case, calling an unimplemented endpoint will also result in a panic at runtime, but the main difference here is that this types embedding will help you to catch the unimplemented endpoints at compile time. This means that each time you add a rpc endpoint it will force you to implement it in your Go code. I actually like that approach more but the problem of panic at runtime is still here.</p> <p>So in most of cases this is something you will not use because this is similar to the previous type embedding we showed. It will panic at runtime if a rpc endpoint is not defined. However, if you can control all your clients and servers, meaning that you can update all of them at the same time (and for eternity), this type embedding is actually safer (ironic, right ?) because it helps you to discover all the unimplemented rpc endpoint in your service at compile time.</p> <h2 id="unimplementedservicenameserver">Unimplemented${ServiceName}Server</h2> <p>And now, here is the one that you should use in most of the cases. This type embedding, as mentionned earlier will get a default implementation for all rpc endpoint added in the service. This means that for the service that we defined earlier, we are going to have the following method generated:</p> <div class="code_switcher_container_parent aa7a390f-7d71-4abf-a45b-fe86cec2d98a"><div class="code_switcher_code_action_container"><button class="code_switcher_theme_button" onclick="updateTheme(true)"></button></div> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">UnimplementedDummyServiceServer</span><span class="p">)</span> <span class="n">GetDummy</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">,</span> <span class="o">*</span><span class="n">emptypb</span><span class="o">.</span><span class="n">Empty</span><span class="p">)</span> <span class="p">(</span><span class="o">*</span><span class="n">emptypb</span><span class="o">.</span><span class="n">Empty</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">status</span><span class="o">.</span><span class="n">Errorf</span><span class="p">(</span><span class="n">codes</span><span class="o">.</span><span class="n">Unimplemented</span><span class="p">,</span> <span class="s">"method GetDummy not implemented"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> </div> <p>And now we basically have Forward Compatibility because if a service without full implementation is called, it will just return a gRPC error and will not panic.</p> <h2 id="conclusion">Conclusion</h2> <p>In conclusion, you might have use cases where you actually need <code>Unsafe</code> type embedding but most of the time use the <code>Unimplemented</code> one. As for the other type embedding, forget it, there is no advantage in using it, only disadvantages. I hope this was helpful and see you in the next post.</p> </div> <div class="date"> Written on December 10, 2022 </div> <div class="comments"> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'clement-jean-github-io-1'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript> </div> </article> </div> <div class="wrapper-footer"> <div class="container"> <footer class="footer"> <a href="mailto:clement.jean@epitech.eu"><i class="svg-icon email"></i></a> <a href="https://github.com/Clement-Jean"><i class="svg-icon github"></i></a> <a href="https://www.linkedin.com/in/clement-jean"><i class="svg-icon linkedin"></i></a> <a href="/feed.xml"><i class="svg-icon rss"></i></a> <a href="https://www.twitter.com/ClmentJean1"><i class="svg-icon twitter"></i></a> <a href="http://stackoverflow.com/users/11269045/clément-jean"><i class="svg-icon stackoverflow"></i></a> <a href="https://techhub.social/@clementjean"><i class="svg-icon mastodon"></i></a> </footer> </div> </div> <!-- Google Analytics --> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-111260962-1', 'auto'); ga('send', 'pageview', { 'page': '/grpc_go_embeddings/', 'title': 'gRPC Go Server Embeddings' }); </script> <!-- End Google Analytics --> </body> </html>
